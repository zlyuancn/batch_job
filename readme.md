

<!-- TOC -->

- [任务处理流程](#%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B)
    - [管理端控制](#%E7%AE%A1%E7%90%86%E7%AB%AF%E6%8E%A7%E5%88%B6)
    - [业务控制](#%E4%B8%9A%E5%8A%A1%E6%8E%A7%E5%88%B6)
- [启动器](#%E5%90%AF%E5%8A%A8%E5%99%A8)
- [自动恢复运行](#%E8%87%AA%E5%8A%A8%E6%81%A2%E5%A4%8D%E8%BF%90%E8%A1%8C)
    - [管理端/接口调用启动](#%E7%AE%A1%E7%90%86%E7%AB%AF%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%E5%90%AF%E5%8A%A8)
    - [启动器上限](#%E5%90%AF%E5%8A%A8%E5%99%A8%E4%B8%8A%E9%99%90)
- [如何并行执行任务数据处理](#%E5%A6%82%E4%BD%95%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86)
    - [仅储存任务进度. 之后的数据通过滑动窗口取出批次数据并行扔给业务处理, 滑动窗口起点表示之前的所有数据都处理完毕, 定时同步滑动窗口进度](#%E4%BB%85%E5%82%A8%E5%AD%98%E4%BB%BB%E5%8A%A1%E8%BF%9B%E5%BA%A6-%E4%B9%8B%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E9%80%9A%E8%BF%87%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%8F%96%E5%87%BA%E6%89%B9%E6%AC%A1%E6%95%B0%E6%8D%AE%E5%B9%B6%E8%A1%8C%E6%89%94%E7%BB%99%E4%B8%9A%E5%8A%A1%E5%A4%84%E7%90%86-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E8%B5%B7%E7%82%B9%E8%A1%A8%E7%A4%BA%E4%B9%8B%E5%89%8D%E7%9A%84%E6%89%80%E6%9C%89%E6%95%B0%E6%8D%AE%E9%83%BD%E5%A4%84%E7%90%86%E5%AE%8C%E6%AF%95-%E5%AE%9A%E6%97%B6%E5%90%8C%E6%AD%A5%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E8%BF%9B%E5%BA%A6)
    - [一些被弃用的方案](#%E4%B8%80%E4%BA%9B%E8%A2%AB%E5%BC%83%E7%94%A8%E7%9A%84%E6%96%B9%E6%A1%88)
        - [仅储存进度. 串行化执行, 让业务控制并发量. 业务主动告知平台本次处理完成了多少任务量](#%E4%BB%85%E5%82%A8%E5%AD%98%E8%BF%9B%E5%BA%A6-%E4%B8%B2%E8%A1%8C%E5%8C%96%E6%89%A7%E8%A1%8C-%E8%AE%A9%E4%B8%9A%E5%8A%A1%E6%8E%A7%E5%88%B6%E5%B9%B6%E5%8F%91%E9%87%8F-%E4%B8%9A%E5%8A%A1%E4%B8%BB%E5%8A%A8%E5%91%8A%E7%9F%A5%E5%B9%B3%E5%8F%B0%E6%9C%AC%E6%AC%A1%E5%A4%84%E7%90%86%E5%AE%8C%E6%88%90%E4%BA%86%E5%A4%9A%E5%B0%91%E4%BB%BB%E5%8A%A1%E9%87%8F)
        - [将每个数据扔给mq, 让mq来并行消费调用业务处理](#%E5%B0%86%E6%AF%8F%E4%B8%AA%E6%95%B0%E6%8D%AE%E6%89%94%E7%BB%99mq-%E8%AE%A9mq%E6%9D%A5%E5%B9%B6%E8%A1%8C%E6%B6%88%E8%B4%B9%E8%B0%83%E7%94%A8%E4%B8%9A%E5%8A%A1%E5%A4%84%E7%90%86)
        - [使用bit位来表示一条数据是否完成, 将bit数据放入redis中](#%E4%BD%BF%E7%94%A8bit%E4%BD%8D%E6%9D%A5%E8%A1%A8%E7%A4%BA%E4%B8%80%E6%9D%A1%E6%95%B0%E6%8D%AE%E6%98%AF%E5%90%A6%E5%AE%8C%E6%88%90-%E5%B0%86bit%E6%95%B0%E6%8D%AE%E6%94%BE%E5%85%A5redis%E4%B8%AD)
        - [将bit位存放在服务本地内存, 定时刷新到redis](#%E5%B0%86bit%E4%BD%8D%E5%AD%98%E6%94%BE%E5%9C%A8%E6%9C%8D%E5%8A%A1%E6%9C%AC%E5%9C%B0%E5%86%85%E5%AD%98-%E5%AE%9A%E6%97%B6%E5%88%B7%E6%96%B0%E5%88%B0redis)
        - [仅储存任务进度, 将一段数据作为一批次数据, 只有这一批次数据全部执行完毕才会更新进度](#%E4%BB%85%E5%82%A8%E5%AD%98%E4%BB%BB%E5%8A%A1%E8%BF%9B%E5%BA%A6-%E5%B0%86%E4%B8%80%E6%AE%B5%E6%95%B0%E6%8D%AE%E4%BD%9C%E4%B8%BA%E4%B8%80%E6%89%B9%E6%AC%A1%E6%95%B0%E6%8D%AE-%E5%8F%AA%E6%9C%89%E8%BF%99%E4%B8%80%E6%89%B9%E6%AC%A1%E6%95%B0%E6%8D%AE%E5%85%A8%E9%83%A8%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%AF%95%E6%89%8D%E4%BC%9A%E6%9B%B4%E6%96%B0%E8%BF%9B%E5%BA%A6)

<!-- /TOC -->
---

# 任务处理流程

## 管理端控制

```mermaid
sequenceDiagram
participant a as 管理端
participant b as 批量工具
participant c as mq
participant d as mysql
participant e as redis
participant f as 业务

opt 注册业务
a ->> b: 注册业务
b -->> b: 数据检查
b ->> c: 增加业务id
b ->> a: ok
end

opt 创建批量任务
a ->> b: 创建批量任务
b -->> e: 生成任务单号
b ->> f: 创建回调
f -->> f: 数据检查等
b ->> d: 写入任务信息到数据库(包含用户列表或者用户url)
b ->> a: ok
end

opt 启动批量任务
a ->> b: 启动批量任务
b -->> e: 获取操作锁, defer 自动解锁
b -->> d: 获取任务信息. 对于运行中的任务, 需要从redis获取进度并从redis获取失败数
alt 对于非 已创建/已停止 状态
  b ->> a: err
end
b ->> d: 更新状态为运行中/等待业务运行
par
  b -->> b: defer 如果流程失败则更新状态为已停止
  b ->> e: 删除停止flag
  b ->> b: 创建启动器
end
b ->> a: ok
end

opt 暂停/停止批量任务
  a->>b: 停止任务
  b -->> e: 获取操作锁, defer 自动解锁
  alt 任务状态不是 运行中/等待业务主动启动
     b -->> a: err
  end
  b->>c: 写入停止信号, 带有效期7天
  b->>e: 更新任务状态为正在停止
  b->>a: ok
end
```

## 业务控制

```mermaid
sequenceDiagram
participant f as 业务层
participant b as 批量工具
participant d as mysql
participant e as redis

opt 业务启动批量任务
f ->> b: 业务启动批量任务
b -->> d: 获取任务信息
alt 对于非 等待业务主动启动 状态的任务
  b ->> f: err
end

b ->> d: 更新状态为运行中
b ->> b: 创建启动器

b ->> f: ok
end

opt 业务停止. 一般为业务判断任务无法继续推进的时候
  f ->> b: 停止任务
  b ->> e: 写入停止标记
  b ->> f: ok
end

opt 更新业务数据. 要求任务必须处于非运行状态
  f ->> b: 更新业务数据
  b ->> d: 获取业务数据信息
  alt 对于运行中的任务
    b ->> f: err
  end
  b ->> d: 更新数据
  b ->> f: ok
end

opt 写入数据日志
  f ->> b: 写入数据日志
  b ->> d: 写入数据日志
  b ->> f: ok
end
```

---

# 启动器

在管理端和程序启动时会创建一个启动器.

启动器创建后会获取任务执行锁. 锁ttl一般为5分钟. 如果获取成功, 则每隔 ttl*1/3 时间为锁续期.

启动器成功创建时会增加当前节点的任务执行数

```mermaid
sequenceDiagram
participant b as 服务
participant c as redis
participant d as mysql
participant f as 业务

alt 业务层注册了启动前回调&&不是由业务创建的启动器
  b ->> c: 写入启动器回调锁. 锁ttl约30分钟. 这是有部分业务在启动前可能会下载数据. 需要给充足的下载时间
  b ->> f: 启动前回调
  f -->> f: 数据检查, 数据下载, 缓存创建等
  b ->> b: 结束
end

b ->> c: 写入任务锁. 锁ttl约为10分钟
b ->> c: defer 解除任务锁

b ->> b: 增加节点的已执行任务数
par 协程
  loop 间隔2分钟
   b -->> c: 对锁续期
  end
end

alt 任务进度已达标
  b ->> d: 更新进度和任务状态和错误数
end

b ->> c: 将当前进度写入到缓存中

b ->> b: 根据当前进度创建滑动窗口, 窗口大小为批次速率的2倍

loop 滑动窗口还有任务未执行完毕
  b ->> b: 获取限速令牌
  
  b -->> c: 获取停止flag(1分钟触发一次)
  alt 收到停止信号
    b ->> d: 更新进度和任务状态和错误数
  end
  
  par
    b -->> f: 处理回调
    f ->> f: 根据传入数据索引号处理数据
    alt 错误累计
      b ->> b: 获取错误累计令牌, 如果拿不到则表示本次无法继续执行了. 应该退出这个过程
    end
    b ->> b: 更新滑动窗口中索引数据号为已完成. 如果这个索引号之前的任务都完成. 则更新当前偏移值和最大区块值(滑动窗口)
  end
end
b ->> b: 等待区块任务执行完毕
b ->> c: 更新进度
```

---

# 自动恢复运行

启动器执行过程中, 可能由于服务器宕机/业务层处理无法进行等原因异常. 我们需要在启动器停止一段时间后自动恢复执行.

这里使用定时器扫描所有运行中的任务, 如果没有超过速率上限, 则对运行中的任务触发启动创建一个任务启动器.

仅扫描配置时间内创建的任务, 比如一个月, 创建时间超过一个月的任务则不会主动恢复. 必须主动点击运行以激活.

```mermaid
sequenceDiagram
participant a as 定时器
participant b as 服务
participant c as redis
participant d as mysql

opt 定时任务启动
a ->> b: 触发

b -->> d: 获取最近正在运行的任务列表
b -->> b: 获取节点的速率上限

loop 遍历每一条任务
  alt 如果累加该任务速率超过节点速率上限
    b ->> a: 结束
  end
  b ->> c: 尝试获取启动锁
  alt 获取启动锁失败
    b ->> a: 结束
  end
  b -->> b: 增加速率上限
  b ->> b: 创建启动器
end
b ->> a: 结束
end
```

## 管理端/接口调用启动

直接触发启动创建一个任务启动器

```mermaid
sequenceDiagram
participant api
participant b as 服务
participant d as mysql

opt api启动
api ->> b: 触发
b ->> d: 更新任务状态
par 异步执行
  alt 如果执行该任务超过速率上限
    b ->> b: 结束
  end
  b ->> b: 创建启动器
end
b ->> api: ok
end
```

## 启动器上限

提供最大速率上限配置, 当前执行的所有任务速率总和不允许超过这个上限. 包括主动执行也不允许让当前节点超过这个速率上限.

---

# 如何并行执行任务数据处理

## 仅储存任务进度. 之后的数据通过滑动窗口取出批次数据并行扔给业务处理, 滑动窗口起点表示之前的所有数据都处理完毕, 定时同步滑动窗口进度

优点, 对于进度的储存占用空间忽略不计, 更新io耗时降低为O(1). 且进度同步是间隔的而不是每次更新就同步. 进一步降低io消耗. 业务的并行执行速度得到最大的发挥. 一批次中的一条任务执行完毕后会立即进行下一条处理, 业务节点的性能得到大幅释放, 且消费速率曲线稳定. 速率由批量任务平台精确控制, 业务层无需考虑并行/速率的实现, 只需要考虑对单条数据的处理.

缺点. 滑动窗口一般为业务并行处理速率的n倍, 一旦批量任务平台执行该任务的节点异常丢失节点. 最复杂的情况下需要重跑整个滑动窗口长度的数据量.

滑动窗口实现原理转到[这里](https://github.com/zlyuancn/sliding_window)

## 一些被弃用的方案

### 仅储存进度. 串行化执行, 让业务控制并发量. 业务主动告知平台本次处理完成了多少任务量

优点. 业务对进度和并发自主可控

缺点. 业务想要并行执行需要自行实现, 处理速率也需要业务实现, 业务需要主动报告, 平台对任务的速率无法控制.

### 将每个数据扔给mq, 让mq来并行消费调用业务处理

增加了一个新的mq系统. 业务会变得更加复杂. 且, 数据扔给mq会导致数据膨胀, 比如将索引1的数据扔给mq, 除了数据本身之外, mq的系统会为这个数据增加一些mq系统独有的内容来支撑mq运行. 而且增加了对mq的io消耗. 如果数据量非常大则产生非常高的mq系统费用.

### 使用bit位来表示一条数据是否完成, 将bit数据放入redis中

这里通过扫描bit位拿到未完成的一批次数据, 循环产生协程调用业务处理. 处理完成的任务更新bit位.

缺点. 对于100亿数据. 会占用 1.16GB的bit数据来表示. 对redis来说比较高了. 且扫描redis中的为0或1的bit位耗时为O(N)

### 将bit位存放在服务本地内存, 定时刷新到redis

缺点. 100亿数据每次同步bit位会写入1.16GB数据, 对redis负担巨大

### 仅储存任务进度, 将一段数据作为一批次数据, 只有这一批次数据全部执行完毕才会更新进度

优点, 对于进度的储存占用空间忽略不计, 更新io耗时降低为O(1). 将这一批次的数据全部协程扔给业务处理. 如果有错误需要重试这些数据直到这批次数据全部处理完成后才会开始下一批次的处理. 一批次处理完成后就更新任务进度

可以考虑间隔同步进度而不是试试同步进度. 这样可以进一步降低进度同步消耗io, 即使同步失败, 只有节点本身异常导致进度丢失才会真的丢失最新进度.

缺点. 

一批次中的数据不一定是同时完成的, 比如业务具备100条的并行处理速度, 当其中50条完成了. 需要等待另外50条也完成才会开始下一批次的处理. 浪费至少一半的节点资源.

一批次中部分数据处理失败虽然会重试, 但是会降低处理速率. 比如业务具备100条的并行处理速度. 我们扔给业务100条数据. 其中有3条失败, 则我们下一次将这3条错误数据扔给业务重试. 此时业务只能并行执行3条. 浪费了97%的资源.





